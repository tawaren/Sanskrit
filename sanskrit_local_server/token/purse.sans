module Purse {
    type <Indexed, Create, Persist> Purse[phantom O, phantom C] {
        Purse($privateId, Token.Token[C]);
    };

    public risky<$NumericError> fun deposit[phantom O, phantom C](consume p:.Purse[O,C], consume t:Token.Token[C]):(pn:.Purse[O,C]) {
        (idx,tokenP) = unpack p:.Purse[O,C];
        tokenR = call Token.merge[C](tokenP,t);
        pn = pack .Purse[O,C]#Purse(idx,tokenR);
        return pn;
    };

    protected[O] risky<$NumericError> fun withdraw[phantom O, phantom C](consume p:.Purse[O,C], amount:$u128):(pn:.Purse[O,C], split:Token.Token[C]) {
        (idx,tokenP) = unpack p:.Purse[O,C];
        (tokenS, tokenR) = call Token.split[C](tokenP,amount);
        pn = pack .Purse[O,C]#Purse(idx,tokenR);
        return (pn,tokenS);
    };
}