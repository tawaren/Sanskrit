use model::*;
use sanskrit_core::model::bitsets::*;
use std::str::FromStr;

grammar;

pub Module:Module =  "module" <name:Id> "{" <components:Semi<Component>> "}" => Module{name,components};

pub Transactions:Vec<Component> = <components:Semi<Transaction>> => components;

Transaction:Component = {
    <transactional:Matches<"transactional">> "transaction" "(" <params:Comma<In>> ")" ":" "(" <returns:Comma<Out>> ")" <code:Block> => Component::Txt{transactional, params,returns,code},
    <transactional:Matches<"transactional">> "transaction" "(" <params:Comma<In>> ")" <code:Block> => Component::Txt{transactional, params,returns:vec![],code},
    <transactional:Matches<"transactional">> "transaction" ":" "(" <returns:Comma<Out>> ")" <code:Block> => Component::Txt{transactional, params:vec![],returns,code},
    <transactional:Matches<"transactional">> "transaction" <code:Block> => Component::Txt{transactional, params:vec![],returns:vec![],code},
};

Component:Component = {
    <perms:Seq<Permissions>> "impl" <name:Id> <generics:EmptyFallback<Generics>> "(" <captures:Comma<Var>> ")" "for" <sig:Type> "(" <params:Comma<Id>> ")" <code:Block> => Component::Impl{perms,name,generics,captures,sig, params, code},
    <perms:Seq<Permissions>> <top:Matches<"top">> "type" <caps:OptionalCaps> <name:Id> <generics:EmptyFallback<Generics>> <ctrs:EmptyFallback<Cases>> => Component::Adt{perms,top,caps,name,generics,ctrs},
    <perms:Seq<Permissions>> <top:Matches<"top">> "extType" "(" <size:Num> ")" <caps:OptionalCaps> <name:Id> <generics:EmptyFallback<Generics>> => Component::ExtLit{perms,top,caps,name,generics,size},
    <perms:Seq<Permissions>> <transactional:Matches<"transactional">> "sig" <caps:OptionalCaps> <name:Id> <generics:EmptyFallback<Generics>> "(" <params:Comma<Var>> ")" ":" "(" <returns:Comma<Ret>> ")" => Component::Sig{perms,transactional,caps,name,generics,params,returns},
    <perms:Seq<Permissions>> <transactional:Matches<"transactional">> "fun" <name:Id> <generics:EmptyFallback<Generics>> "(" <params:Comma<Var>> ")" ":" "(" <returns:Comma<Ret>> ")" <code:Block> => Component::Fun{perms,transactional,name,generics,params,returns,code},
    <perms:Seq<Permissions>> <transactional:Matches<"transactional">> "extFun" <name:Id> <generics:EmptyFallback<Generics>> "(" <params:Comma<Var>> ")" ":" "(" <returns:Comma<Ret>> ")" => Component::ExtFun{perms,transactional,name,generics,params,returns},
};

Generics:Vec<Generic> = "[" <generics:Comma<Generic>> "]" => generics;
OptionalCaps:CapSet = {
    => CapSet::empty(),
    "<" <caps:Caps> ">" => caps,
};
Cases:Vec<Case> = "{" <ctrs:Semi<Case>> "}" => ctrs;

Permissions:(Vec<Id>, Visibility) = {
    <v:Visibility> => (vec![Id("default".to_string())],v),
    <v:Visibility> "(" <ids:Comma<Permission>> ")" => (ids,v),
}

Permission:Id = {
    "create" => Id("create".to_string()),
    "consume" => Id("consume".to_string()),
    "inspect" => Id("inspect".to_string()),
    "call" => Id("call".to_string()),
    "implement" => Id("implement".to_string()),
}

Caps: CapSet = {
    <v:(<Cap> ",")*> <e:Cap?> => match e {
        None => CapSet(v.iter().fold(0,|a,b|a|b)),
        Some(e) => CapSet(v.iter().fold(e,|a,b|a|b))
    }
};

Cap: u8 = {
    "Drop" => 1 << 0,
    "Copy" => 1 << 1,
    "Persist" => 1 << 2,
    "Primitive" => 1 << 3,
    "Value" => 1 << 4,
    "Unbound" => 1 << 5,
}

Generic:Generic = {
    <caps:OptionalCaps>  <name:Id> => Generic{name,caps,phantom:false},
    "phantom" <caps:OptionalCaps> <name:Id> => Generic{name,caps,phantom:true},
}

Visibility:Visibility = {
    "private" => Visibility::Private,
    "public" => Visibility::Public,
    "protected" "[" <protects:Comma<Id>> "]" => Visibility::Protected(protects),
}

Case:Case = {
    <name:Id> "(" <params:Comma<Type>> ")" => Case{name,params},
    <name:Id> => Case{name,params:vec![]},
};

Type:Type = {
    <p:("%")*> <main:Ref> "[" <applies:Comma<Type>> "]" => Type{main,applies,projections:p.len()},
    <p:("%")*> <main:Ref> => Type{main,applies:vec![],projections:p.len()},

};

Ref:Ref = {
    <name:Id> => Ref::Generic(name),
    "this" "." <name:Id> => Ref::This(name),
    "." <name:Id> => Ref::This(name),
    <module:Id> "." <name:Id> => Ref::Module(Id(module.0.to_lowercase()),name),
};

Block:Block = {
    "{" <codes:Semi<OpCode>> "}" => Block{codes},
    "{" <codes:Semi<OpCode>> ";" "}" => Block{codes},
};

OpCode:OpCode = {
    <id:Assign> "lit" <lit:Lit> ":" <typ:Type> => OpCode::Lit(id, lit, typ),
    <vars:Assigns> "let" <b:Block> => OpCode::Let(vars, Box::new(b)),
    "let" <b:Block> => OpCode::Let(vec![], Box::new(b)),
    <id:Assign> "copy" <var:Id> => OpCode::Copy(id,var),
    <id:Assign> "project" <var:Id> ":" <typ:Type>  => OpCode::Project(id,var,typ),
    <id:Assign> "unproject" <var:Id> ":" <typ:Type> => OpCode::UnProject(id,var,typ),
    <id:Assign>  <var:Id> => OpCode::Fetch(id,var),
    <assigs:Assigns> "(" <ids:Comma<Id>> ")" => OpCode::Return(assigs,ids),
    "return" => OpCode::Return(vec![],vec![]),
    "discard" <id:Id> => OpCode::Discard(id),
    "discard" "(" <ids:Comma<Id>> ")" => OpCode::DiscardMany(ids),
    <id:Assign> "field" "[" <n:Lit> "]" <var:Id> ":" <typ:Type>  => OpCode::Field(id,var,n,typ),
    <id:Assign> "copy field" "[" <n:Lit> "]" <var:Id> ":" <typ:Type> => OpCode::CopyField(id,var,n,typ),
    <assigs:Assigns> "unpack" <var:Id>  ":" <typ:Type> => OpCode::Unpack(assigs,var,typ),
    <assigs:Assigns> "switch" <var:Id> ":" <typ:Type> "{" <matches:Semi<Match>> "}" => OpCode::Switch(assigs,var,typ,matches),
    <assigs:Assigns> "inspect" <var:Id> ":" <typ:Type> "{" <matches:Semi<Match>> "}" => OpCode::Inspect(assigs,var,typ,matches),
    <id:Assign> "pack" <typ:Type> "#" <ctr:Id> "(" <vars:Comma<Id>> ")" => OpCode::Pack(id,typ,ctr,vars),
    <id:Assign> "capture" <sig:Type> "(" <vars:Comma<Id>> ")" => OpCode::CreateSig(id,sig,vars),
    <assigs:Assigns> "callSig" <target:Id> ":" <typ:Type> "(" <vars:Comma<Id>> ")" =>  OpCode::CallSig(assigs, target, typ, vars),

    <assigs:Assigns> "call" <function:Ref> "[" <generics:Comma<Type>> "]" "(" <vars:Comma<Id>> ")" =>  OpCode::Call(assigs, function, generics, vars),
    <assigs:Assigns> "call" <function:Ref> "(" <vars:Comma<Id>> ")" =>  OpCode::Call(assigs, function, vec![], vars),

    <assigs:Assigns> "try" "call" <function:Ref> "[" <generics:Comma<Type>> "]" "(" <vars:Comma<MarkedId>> ")" "{" <matches:Semi<Match>> "}" =>  OpCode::TryCall(assigs, function, generics, vars, matches),
    <assigs:Assigns> "try" "call" <function:Ref> "(" <vars:Comma<MarkedId>> ")" "{" <matches:Semi<Match>> "}" =>  OpCode::TryCall(assigs, function, vec![], vars, matches),

    <assigs:Assigns> "abort" "(" <vars:Comma<Id>> ")" ":" "(" <typs:Comma<Type>> ")" => OpCode::Abort(assigs,vars,typs),
    <assigs:Assigns> "abort" ":" "(" <typs:Comma<Type>> ")" => OpCode::Abort(assigs,vec![],typs),
    "abort" "(" <vars:Comma<Id>> ")"  => OpCode::Abort(vec![],vars,vec![]),
    "abort" => OpCode::Abort(vec![],vec![],vec![]),
};

MarkedId:(bool, Id) = {
    "!" <id:Id> => (false, id),
    <id:Id> => (true, id),
}

Assign:Id = {
    <id:Id> "=" => id,
    "return" =>  Id("$ret".into()),
};

Assigns:Vec<Id> = {
    <id:Id> "=" => vec![id],
    "(" <ids:Comma<Id>> ")" "=" => ids,
    "return" => vec![],
}

Match:Match = {
    <ctr:Id> "(" <params:Comma<Id>> ")" "=>" <code:Block> => Match{ctr,params,code},
    <ctr:Id> "=>" <code:Block> => Match{ctr,params:vec![],code},
};

In:In = {
    "copy" "(" <key:Key> ")" <name:Id> ":" <typ:Type> => In::Copy(key,name,typ),
    "borrow" "(" <key:Key> ")" <name:Id> ":" <typ:Type> => In::Borrow(key,name,typ),
    "consume" "(" <key:Key> ")" <name:Id> ":" <typ:Type> => In::Consume(key,name,typ),
    "literal" "(" <data:Data> ")" <name:Id> ":" <typ:Type> => In::Literal(data,name,typ),
    "witness" "(" <data:Data> ")" <name:Id> ":" <typ:Type> => In::Witness(data,name,typ),
    "provided" <name:Id> ":" <typ:Type> => In::Provided(name,typ),

};

Key:Key = {
    <key:Lit> => Key::Plain(key),
    <module:Id> "(" <key:Lit> ")" => Key::Derived(Id(module.0.to_lowercase()), key),
}

Out:Out = {
    "store" <name:Id> ":" <typ:Type> => Out::Store(name,typ),
    "drop" <name:Id> ":" <typ:Type> => Out::Drop(name,typ),
    "log" <name:Id> ":" <typ:Type> => Out::Log(name,typ),
}

Data:Data = {
    <typ:Ref> "#" <ctr:Id> "(" <params:Comma<Data>> ")" => Data::Adt{typ,ctr,params},
    <typ:Ref> <lit:Lit> => Data::Lit{typ,lit},
}

Var:Var = {
    "consume" <name:Id> ":" <typ:Type> => Var{name,consume:true,typ},
    <name:Id> ":" <typ:Type> => Var{name,consume:false,typ},
};

Ret:Ret = <name:Id> ":" <typ:Type> => Ret{name,typ};

Id:Id = <s:r"[_a-zA-Z][_a-zA-Z0-9]*"> => Id(s.into());

Lit:Lit = {
    <s:r"(-)?[0-9]+"> => Lit(s.into()),
    <s:r"0x[0-9a-fA-F]+"> => Lit(s.into()),
};

Num:u16 = <s:r"(-)?[0-9]+"> => u16::from_str(s).unwrap();


Semi<T>: Vec<T> = {
    <v:(<T> ";")+> => v
};

Seq<T>: Vec<T> = {
    <v:(<T>)*> => v
};

EmptyFallback<T>:T = {
    <t:T> => t,
    => vec![],
}

Matches<T>:bool = {
    <t:T> => true,
    => false,
}

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};