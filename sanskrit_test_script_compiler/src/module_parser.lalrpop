use model::*;
use sanskrit_common::capabilities::CapSet;
use std::str::FromStr;

grammar;

pub Module:Module =  "module" <name:Id> "{" <components:Semi<Component>> "}" => Module{name,components};

Component:Component = {
    "type" "<" <caps:Caps> ">" <name:Id> "[" <generics:Comma<Generic>>  "]" "{" <ctrs:Semi<Case>> "}" => Component::Adt{caps,name,generics,ctrs},
    "type"  <name:Id> "[" <generics:Comma<Generic>>  "]" "{" <ctrs:Semi<Case>> "}" => Component::Adt{caps:CapSet::empty(),name,generics,ctrs},
    "type" "<" <caps:Caps> ">" <name:Id>  "{" <ctrs:Semi<Case>> "}" => Component::Adt{caps,name,generics:vec![],ctrs},
    "type"  <name:Id> "{" <ctrs:Semi<Case>> "}" => Component::Adt{caps:CapSet::empty(),name,generics:vec![],ctrs},

    "type" "<" <caps:Caps> ">" <name:Id> "[" <generics:Comma<Generic>>  "]" => Component::Adt{caps,name,generics,ctrs:vec![]},
    "type"  <name:Id> "[" <generics:Comma<Generic>>  "]" => Component::Adt{caps:CapSet::empty(),name,generics,ctrs:vec![]},
    "type" "<" <caps:Caps> ">" <name:Id>  => Component::Adt{caps,name,generics:vec![],ctrs:vec![]},
    "type"  <name:Id>  => Component::Adt{caps:CapSet::empty(),name,generics:vec![],ctrs:vec![]},

    "external" "(" <id:Num> ")" "type" "<" <caps:Caps> ">" <name:Id> "[" <generics:Comma<Generic>>  "]" => Component::ExtAdt{id,caps,name,generics},
    "external" "(" <id:Num> ")" "type"  <name:Id> "[" <generics:Comma<Generic>>  "]" => Component::ExtAdt{id,caps:CapSet::empty(),name,generics},
    "external" "(" <id:Num> ")" "type" "<" <caps:Caps> ">" <name:Id>  => Component::ExtAdt{id,caps,name,generics:vec![]},
    "external" "(" <id:Num> ")" "type"  <name:Id>  => Component::ExtAdt{id,caps:CapSet::empty(),name,generics:vec![]},

    "lit" "(" <size:Num> ")" "<" <caps:Caps> ">" <name:Id> "[" <generics:Comma<Generic>>  "]" => Component::Lit{caps,name,generics,size},
    "lit" "(" <size:Num> ")" <name:Id> "[" <generics:Comma<Generic>>  "]" => Component::Lit{caps:CapSet::empty(),name,generics,size},
    "lit" "(" <size:Num> ")" "<" <caps:Caps> ">" <name:Id>  => Component::Lit{caps,name,generics:vec![],size},
    "lit" "(" <size:Num> ")" <name:Id>  => Component::Lit{caps:CapSet::empty(),name,generics:vec![],size},

    "external" "(" <id:Num> ")" "lit" "(" <size:Num> ")" "<" <caps:Caps> ">" <name:Id> "[" <generics:Comma<Generic>>  "]" => Component::ExtLit{id,caps,name,generics,size},
    "external" "(" <id:Num> ")" "lit" "(" <size:Num> ")" <name:Id> "[" <generics:Comma<Generic>>  "]" => Component::ExtLit{id,caps:CapSet::empty(),name,generics,size},
    "external" "(" <id:Num> ")" "lit" "(" <size:Num> ")" "<" <caps:Caps> ">" <name:Id>  => Component::ExtLit{id,caps,name,generics:vec![],size},
    "external" "(" <id:Num> ")" "lit" "(" <size:Num> ")" <name:Id>  => Component::ExtLit{id,caps:CapSet::empty(),name,generics:vec![],size},

    "err" <name:Id> => Component::Err{name},

    "risky" "<" <risks:Comma<Ref>> ">" "fun" <name:Id> "[" <generics:Comma<Generic>> "]" "(" <params:Comma<Var>> ")" ":" "(" <returns:Comma<Ret>> ")" <code:Block> => Component::Fun{name,vis:Visibility::Private,risks,generics,params,returns,code},
    "risky" "<" <risks:Comma<Ref>> ">" "fun" <name:Id> "(" <params:Comma<Var>>  ")" ":" "(" <returns:Comma<Ret>> ")" <code:Block> => Component::Fun{name,vis:Visibility::Private,risks,generics:vec![],params,returns,code},
    "fun" <name:Id> "[" <generics:Comma<Generic>> "]" "(" <params:Comma<Var>> ")" ":" "(" <returns:Comma<Ret>> ")" <code:Block> => Component::Fun{name,vis:Visibility::Private,risks:vec![],generics,params,returns,code},
    "fun" <name:Id> "(" <params:Comma<Var>> ")" ":" "(" <returns:Comma<Ret>> ")" <code:Block> => Component::Fun{name,vis:Visibility::Private,risks:vec![],generics:vec![],params,returns,code},
    <vis:Visibility> "risky" "<" <risks:Comma<Ref>> ">" "fun" <name:Id> "[" <generics:Comma<Generic>> "]" "(" <params:Comma<Var>> ")" ":" "(" <returns:Comma<Ret>> ")" <code:Block> => Component::Fun{name,vis,risks,generics,params,returns,code},
    <vis:Visibility> "risky" "<" <risks:Comma<Ref>> ">" "fun" <name:Id> "(" <params:Comma<Var>>  ")" ":" "(" <returns:Comma<Ret>> ")" <code:Block> => Component::Fun{name,vis,risks,generics:vec![],params,returns,code},
    <vis:Visibility> "fun" <name:Id> "[" <generics:Comma<Generic>> "]" "(" <params:Comma<Var>> ")" ":" "(" <returns:Comma<Ret>> ")" <code:Block> => Component::Fun{name,vis,risks:vec![],generics,params,returns,code},
    <vis:Visibility> "fun" <name:Id> "(" <params:Comma<Var>> ")" ":" "(" <returns:Comma<Ret>> ")" <code:Block> => Component::Fun{name,vis,risks:vec![],generics:vec![],params,returns,code},

    "external" "(" <id:Num> ")" "risky" "<" <risks:Comma<Ref>> ">" "fun" <name:Id> "[" <generics:Comma<Generic>> "]" "(" <params:Comma<Var>> ")" ":" "(" <returns:Comma<Ret>> ")" => Component::ExtFun{id,name,vis:Visibility::Private,risks,generics,params,returns},
    "external" "(" <id:Num> ")" "risky" "<" <risks:Comma<Ref>> ">" "fun" <name:Id> "(" <params:Comma<Var>>  ")" ":" "(" <returns:Comma<Ret>> ")" => Component::ExtFun{id,name,vis:Visibility::Private,risks,generics:vec![],params,returns},
    "external" "(" <id:Num> ")" "fun" <name:Id> "[" <generics:Comma<Generic>> "]" "(" <params:Comma<Var>> ")" ":" "(" <returns:Comma<Ret>> ")" => Component::ExtFun{id,name,vis:Visibility::Private,risks:vec![],generics,params,returns},
    "external" "(" <id:Num> ")" "fun" <name:Id> "(" <params:Comma<Var>> ")" ":" "(" <returns:Comma<Ret>> ")" => Component::ExtFun{id,name,vis:Visibility::Private,risks:vec![],generics:vec![],params,returns},
    "external" "(" <id:Num> ")" <vis:Visibility> "risky" "<" <risks:Comma<Ref>> ">" "fun" <name:Id> "[" <generics:Comma<Generic>> "]" "(" <params:Comma<Var>> ")" ":" "(" <returns:Comma<Ret>> ")" => Component::ExtFun{id,name,vis,risks,generics,params,returns},
    "external" "(" <id:Num> ")" <vis:Visibility> "risky" "<" <risks:Comma<Ref>> ">" "fun" <name:Id> "(" <params:Comma<Var>>  ")" ":" "(" <returns:Comma<Ret>> ")" => Component::ExtFun{id,name,vis,risks,generics:vec![],params,returns},
    "external" "(" <id:Num> ")" <vis:Visibility> "fun" <name:Id> "[" <generics:Comma<Generic>> "]" "(" <params:Comma<Var>> ")" ":" "(" <returns:Comma<Ret>> ")" => Component::ExtFun{id,name,vis,risks:vec![],generics,params,returns},
    "external" "(" <id:Num> ")" <vis:Visibility> "fun" <name:Id> "(" <params:Comma<Var>> ")" ":" "(" <returns:Comma<Ret>> ")" => Component::ExtFun{id,name,vis,risks:vec![],generics:vec![],params,returns},

};

Caps: CapSet = {
    <v:(<Cap> ",")*> <e:Cap?> => match e {
        None => CapSet(v.iter().fold(0,|a,b|a|b)),
        Some(e) => CapSet(v.iter().fold(e,|a,b|a|b))
    }
};

Cap: u8 = {
    "Drop" => 1 << 0,
    "Copy" => 1 << 1,
    "Persist" => 1 << 2,
    "Consume" => 1 << 3,
    "Inspect" => 1 << 4,
    "Embed" => 1 << 5,
    "Create" => 1 << 6,
}

Generic:Generic = {
    <name:Id> => Generic{name,caps:CapSet::empty(),phantom:false},
    "phantom" <name:Id> => Generic{name,caps:CapSet::empty(),phantom:true},
    "<" <caps:Caps> ">" <name:Id> => Generic{name,caps,phantom:false},
    "phantom" "<" <caps:Caps> ">" <name:Id> => Generic{name,caps,phantom:true},
}

Visibility:Visibility = {
    "private" => Visibility::Private,
    "public" => Visibility::Public,
    "protected" "[" <protects:Comma<Id>> "]" => Visibility::Protected(protects),
}

Case:Case = {
    <name:Id> "(" <params:Comma<Type>> ")" => Case{name,params},
    <name:Id> => Case{name,params:vec![]},
};

Type:Type = {
    <main:Ref> "[" <applies:Comma<Type>> "]" => Type{main,applies,is_image:false},
    <main:Ref> => Type{main,applies:vec![],is_image:false},
    "%" <main:Ref> "[" <applies:Comma<Type>> "]" => Type{main,applies,is_image:true},
    "%" <main:Ref> => Type{main,applies:vec![],is_image:true},
};

Ref:Ref = {
    <name:Id> => Ref::Generic(name),
    "this" "." <name:Id> => Ref::This(name),
    "." <name:Id> => Ref::This(name),
    <module:Id> "." <name:Id> => Ref::Module(Id(module.0.to_lowercase()),name),
};

Block:Block = {
     "{" <codes:Semi<OpCode>> "return" "(" <ids:Comma<Id>>")" ";" "}" => Block::Return(codes,ids),
     "{" <codes:Semi<OpCode>> "return" <id:Id> ";" "}" => Block::Return(codes,vec![id]),
     "{" <codes:Semi<OpCode>> "return" ";" "}" => Block::Return(codes,vec![]),
     "{" "return" "(" <ids:Comma<Id>> ")" ";" "}"  => Block::Return(vec![],ids),
     "{" "return" <id:Id> ";" "}" => Block::Return(vec![],vec![id]),
     "{" "return" ";" "}" => Block::Return(vec![],vec![]),
     "{" "throw" <err:Ref> ";" "}" => Block::Error(err),
};

OpCode:OpCode = {
    <id:Id> "=" "lit" <lit:Lit> ":" <typ:Type> => OpCode::Lit(id, lit, typ),
    <vars:Assigns> "let" <b:Block> => OpCode::Let(vars, Box::new(b)),
    "let" <b:Block> => OpCode::Let(vec![], Box::new(b)),
    <id:Id> "=" "copy" <var:Id> => OpCode::Copy(id,var),
    <id:Id> "=" "image" <var:Id> => OpCode::Image(id,var),
    <id:Id> "=" <var:Id> => OpCode::Fetch(id,var,false),
    <id:Id> "=" "&" <var:Id> => OpCode::Fetch(id,var,true),
    "discard" <id:Id> => OpCode::Discard(id),
    "discard" "(" <ids:Comma<Id>> ")" => OpCode::DiscardMany(ids),
    "discard" <trg:Id> "borrowedBy" <src:Id> => OpCode::DiscardBorrowed(trg,vec![src]),
    "discard" <trg:Id> "borrowedBy" "(" <srcs:Comma<Id>> ")" => OpCode::DiscardBorrowed(trg, srcs),
    <id:Id> "=" "field" "[" <n:Lit> "]" <var:Id> ":" <typ:Type>  => OpCode::Field(id,var,n,typ,false),
    <id:Id> "=" "&field" "[" <n:Lit> "]" <var:Id> ":" <typ:Type> => OpCode::Field(id,var,n,typ,true),
    <id:Id> "=" "copy field" "[" <n:Lit> "]" <var:Id> ":" <typ:Type> => OpCode::CopyField(id,var,n,typ),
    <assigs:Assigns> "unpack" <var:Id>  ":" <typ:Type> => OpCode::Unpack(assigs,var,typ,false),
    <assigs:Assigns> "&unpack" <var:Id> ":" <typ:Type> => OpCode::Unpack(assigs,var,typ,true),
    <assigs:Assigns> "switch" <var:Id> ":" <typ:Type> "{" <matches:Semi<Match>> "}" => OpCode::Switch(assigs,var,typ,matches,false),
    <assigs:Assigns> "&switch" <var:Id> ":" <typ:Type> "{" <matches:Semi<Match>> "}" => OpCode::Switch(assigs,var,typ,matches,true),
    <id:Id> "=" "pack" <typ:Type> "#" <ctr:Id> "(" <vars:Comma<Id>> ")" => OpCode::Pack(id,typ,ctr,vars,false),
    <id:Id> "=" "&pack" <typ:Type> "#" <ctr:Id> "(" <vars:Comma<Id>> ")" => OpCode::Pack(id,typ,ctr,vars,true),
    <assigs:Assigns> "call" <function:Ref> "[" <generics:Comma<Type>> "]" "(" <vars:Comma<Id>> ")" =>  OpCode::Call(assigs, function, generics, vars),
    <assigs:Assigns> "call" <function:Ref> "(" <vars:Comma<Id>> ")" =>  OpCode::Call(assigs, function, vec![], vars),
    <assigs:Assigns> "try" <b:Block> "catch" "{" <catches:Semi<Catch>> "}" => OpCode::Try(assigs, Box::new(b), catches),
};

Assigns:Vec<Id> = {
    <id:Id> "=" => vec![id],
    "(" <ids:Comma<Id>> ")" "=" => ids,
}


Catch:Catch = <error:Ref> "=>"  <code:Block> => Catch{error,code};
Match:Match = {
    <ctr:Id> "(" <params:Comma<Id>> ")" "=>" <code:Block> => Match{ctr,params,code},
    <ctr:Id> "=>" <code:Block> => Match{ctr,params:vec![],code},
};

Var:Var = {
    "consume" <name:Id> ":" <typ:Type> => Var{name,consume:true,typ},
    <name:Id> ":" <typ:Type> => Var{name,consume:false,typ},
};

Ret:Ret = {
    "borrowed" "(" <borrow:Comma<Id>> ")"  <name:Id> ":" <typ:Type> => Ret{name,borrow,typ},
    <name:Id> ":" <typ:Type> => Ret{name,borrow:vec![],typ},
};

Id:Id = <s:r"[_a-zA-Z][_a-zA-Z0-9]*"> => Id(s.into());

Lit:Lit = {
    <s:r"(-)?[0-9]+"> => Lit(s.into()),
    <s:r"0x[0-9a-fA-F]+"> => Lit(s.into()),
};

Num:u16 = <s:r"(-)?[0-9]+"> => u16::from_str(s).unwrap();


Semi<T>: Vec<T> = {
    <v:(<T> ";")+> => v
};

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};
