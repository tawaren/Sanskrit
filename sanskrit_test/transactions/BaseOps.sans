module BaseOps {
   type <Copy,Drop,Embed,Create,Consume,Inspect> Wrapper[<Embed> A]{
        Ctr(A);
   };

   type <Copy,Drop,Embed,Create,Consume,Inspect> TwoOfTwo[<Embed> A,<Embed> B]{
        Ctr1(A,B);
        Ctr2(B,A);
   };

   type <Copy,Drop,Embed> Test[<Embed> A, <Embed> B] {
       Ctr1($alt2[A,B]);
       Ctr2($tuple2[A,B]);
       Ctr3(A);
       Ctr4(B);
       Ctr5(.Wrapper[A]);
   };

   fun Extract(consume t:.Test[$u8,.Wrapper[$u8]]):(a:$u8) {
        r = switch t:.Test[$u8,.Wrapper[$u8]] {
             Ctr1(alt) => {
                r = switch alt:$alt2[$u8,.Wrapper[$u8]]  {
                    first(r) => {
                        return r;
                    };
                    second(w) => {
                        r = unpack w:.Wrapper[$u8];
                        return r;
                    };
                };
                return r;
             };
             Ctr2(tup) => {
                r = field[0] tup:$tuple2[$u8,.Wrapper[$u8]];
                return r;
             };
             Ctr3(r) => {
                return r;
             };
             Ctr4(w) => {
                r = unpack w:.Wrapper[$u8];
                return r;
             };
             Ctr5(w) => {
                r = field[0] w:.Wrapper[$u8];
                return r;
             };
        };
        return r;
   };

   fun BorrowOut(t:.Test[$u8,.Wrapper[$u8]]):(borrowed(t) a:$u8) {
        r = &switch t:.Test[$u8,.Wrapper[$u8]] {
             Ctr1(alt) => {
                r = &switch alt:$alt2[$u8,.Wrapper[$u8]]  {
                    first(r) => {
                        return r;
                    };
                    second(w) => {
                        r = &unpack w:.Wrapper[$u8];
                        return r;
                    };
                };
                return r;
             };
             Ctr2(tup) => {
                r = &field[0] tup:$tuple2[$u8,.Wrapper[$u8]];
                return r;
             };
             Ctr3(r) => {
                return r;
             };
             Ctr4(w) => {
                r = &unpack w:.Wrapper[$u8];
                return r;
             };
             Ctr5(w) => {
                r = &field[0] w:.Wrapper[$u8];
                return r;
             };
        };
        return r;
   };


   public risky<Helpers.ValidationError> fun CreateStuff():() {
        a = lit 1:$u8;
        aa = copy a;
        w = pack .Wrapper[$u8]#Ctr(aa);
        c11 = copy a;
        a11 = pack $alt2[$u8,.Wrapper[$u8]]#first(c11);
        t11 = pack .Test[$u8,.Wrapper[$u8]]#Ctr1(a11);
        c12 = copy w;
        a12 = pack $alt2[$u8,.Wrapper[$u8]]#second(c12);
        t12 = pack .Test[$u8,.Wrapper[$u8]]#Ctr1(a12);
        c21 = copy a;
        c22 = copy w;
        a2 = pack $tuple2[$u8,.Wrapper[$u8]]#tuple(c21,c22);
        t2 = pack .Test[$u8,.Wrapper[$u8]]#Ctr2(a2);
        a3 = copy a;
        t3 = pack .Test[$u8,.Wrapper[$u8]]#Ctr3(a3);
        a4 = copy w;
        t4 = pack .Test[$u8,.Wrapper[$u8]]#Ctr4(a4);
        a5 = copy w;
        t5 = pack .Test[$u8,.Wrapper[$u8]]#Ctr5(a5);
        drop w;
        br11 = call .BorrowOut(t11);
        br12 = call .BorrowOut(t12);
        br2 = call .BorrowOut(t2);
        br3 = call .BorrowOut(t3);
        br4 = call .BorrowOut(t4);
        br5 = call .BorrowOut(t5);
        () = call Helpers.AssertEqU8(a,br11);
        () = call Helpers.AssertEqU8(a,br12);
        () = call Helpers.AssertEqU8(a,br2);
        () = call Helpers.AssertEqU8(a,br3);
        () = call Helpers.AssertEqU8(a,br4);
        () = call Helpers.AssertEqU8(a,br5);
        free br11;
        free br12;
        free br2;
        free br3;
        free br4;
        free br5;
        r11 = call .Extract(t11);
        r12 = call .Extract(t12);
        r2 = call .Extract(t2);
        r3 = call .Extract(t3);
        r4 = call .Extract(t4);
        r5 = call .Extract(t5);
        () = call Helpers.AssertEqU8(a,r11);
        () = call Helpers.AssertEqU8(a,r12);
        () = call Helpers.AssertEqU8(a,r2);
        () = call Helpers.AssertEqU8(a,r3);
        () = call Helpers.AssertEqU8(a,r4);
        () = call Helpers.AssertEqU8(a,r5);
        drop a;
        drop r11;
        drop r12;
        drop r2;
        drop r3;
        drop r4;
        drop r5;
        return;
   };

    public risky<Helpers.ValidationError> fun CreateBorrowedStuff():() {
       a = lit 1:$u8;
       aa = copy a;
       w = &pack .Wrapper[$u8]#Ctr(aa);
       c11 = copy a;
       a11 = &pack $alt2[$u8,.Wrapper[$u8]]#first(c11);
       t11 = &pack .Test[$u8,.Wrapper[$u8]]#Ctr1(a11);
       c12 = copy w;
       a12 = &pack $alt2[$u8,.Wrapper[$u8]]#second(c12);
       t12 = &pack .Test[$u8,.Wrapper[$u8]]#Ctr1(a12);
       c21 = copy a;
       c22 = copy w;
       a2 = &pack $tuple2[$u8,.Wrapper[$u8]]#tuple(c21,c22);
       t2 = &pack .Test[$u8,.Wrapper[$u8]]#Ctr2(a2);
       a3 = copy a;
       t3 = &pack .Test[$u8,.Wrapper[$u8]]#Ctr3(a3);
       a4 = copy w;
       t4 = &pack .Test[$u8,.Wrapper[$u8]]#Ctr4(a4);
       a5 = copy w;
       t5 = &pack .Test[$u8,.Wrapper[$u8]]#Ctr5(a5);
       br11 = call .BorrowOut(t11);
       br12 = call .BorrowOut(t12);
       br2 = call .BorrowOut(t2);
       br3 = call .BorrowOut(t3);
       br4 = call .BorrowOut(t4);
       br5 = call .BorrowOut(t5);
       () = call Helpers.AssertEqU8(a,br11);
       () = call Helpers.AssertEqU8(a,br12);
       () = call Helpers.AssertEqU8(a,br2);
       () = call Helpers.AssertEqU8(a,br3);
       () = call Helpers.AssertEqU8(a,br4);
       () = call Helpers.AssertEqU8(a,br5);
       discard(a,aa,c11,c12,c21,c22,a3,a4,a5);
       return;
    };

    public fun Pack[<Embed> A](consume a:A):(w:.Wrapper[A]){
        w = pack .Wrapper[A]#Ctr(a);
        return w;
    };

    public fun BorrowPack[<Embed> A](a:A):(borrowed(a) w:.Wrapper[A]){
        w = &pack .Wrapper[A]#Ctr(a);
        return w;
    };

    public fun Unpack[<Embed> A](consume w:.Wrapper[A]):(a:A){
        a = unpack w:.Wrapper[A];
        return a;
    };

    public fun BorrowUnpack[<Embed> A](w:.Wrapper[A]):(borrowed(w) a:A){
        a = &unpack w:.Wrapper[A];
        return a;
    };

    public fun Pack2[<Embed> A,<Embed> B](consume a:A,consume b:B):(w:.TwoOfTwo[A,B]){
        w = pack .TwoOfTwo[A,B]#Ctr1(a,b);
        return w;
    };

    public fun BorrowPack2[<Embed> A,<Embed> B](a:A, b:B):(borrowed(a,b) w:.TwoOfTwo[A,B]){
        w = &pack .TwoOfTwo[A,B]#Ctr2(b,a);
        return w;
    };

    public fun Unpack2[<Embed> A,<Embed> B](consume w:.TwoOfTwo[A,B]):(a:A,b:B){
        (a,b) = switch w:.TwoOfTwo[A,B] {
            Ctr1(a,b) => {
                return (a,b);
            };
            Ctr2(b,a) => {
                return (a,b);
            };
        };
        return (a,b);
    };

    public fun BorrowUnpack2[<Embed> A,<Embed> B](w:.TwoOfTwo[A,B]):(borrowed(w) a:A, borrowed(w) b:B){
       (a,b) = &switch w:.TwoOfTwo[A,B] {
           Ctr1(a,b) => {
               return (a,b);
           };
           Ctr2(b,a) => {
               return (a,b);
           };
       };
       return (a,b);
    };
}