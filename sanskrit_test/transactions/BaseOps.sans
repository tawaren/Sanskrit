module BaseOps {
   public type <Copy,Drop,Primitive,Persist,Value,Unbound> Wrapper[A]{
        Ctr(A);
   };

   public type <Copy,Drop,Primitive,Persist,Value,Unbound> TwoOfTwo[A,B]{
        Ctr1(A,B);
        Ctr2(B,A);
   };

   public type <Copy,Drop,Primitive,Persist,Value,Unbound> Test[A,B] {
       Ctr1(Alt.Alt2[A,B]);
       Ctr2(Tuple.Tuple2[A,B]);
       Ctr3(A);
       Ctr4(B);
       Ctr5(.Wrapper[A]);
   };

   fun Extract(consume t:.Test[IntU8.U8,.Wrapper[IntU8.U8]]):(a:IntU8.U8) {
        return switch t:.Test[IntU8.U8,.Wrapper[IntU8.U8]] {
             Ctr1(alt) => {
                return switch alt:Alt.Alt2[IntU8.U8,.Wrapper[IntU8.U8]]  {
                    First(r) => {
                        return r;
                    };
                    Second(w) => {
                        return unpack w:.Wrapper[IntU8.U8];
                    };
                };
             };
             Ctr2(tup) => {
                return field[0] tup:Tuple.Tuple2[IntU8.U8,.Wrapper[IntU8.U8]];
             };
             Ctr3(r) => {
                return r;
             };
             Ctr4(w) => {
                return unpack w:.Wrapper[IntU8.U8];
             };
             Ctr5(w) => {
                return field[0] w:.Wrapper[IntU8.U8];
             };
        };
   };

   fun CopyOut(t:.Test[IntU8.U8,.Wrapper[IntU8.U8]]):(a:IntU8.U8) {
        return inspect t:.Test[IntU8.U8,.Wrapper[IntU8.U8]] {
             Ctr1(alt) => {
                return inspect alt:Alt.Alt2[IntU8.U8,.Wrapper[IntU8.U8]]  {
                    First(r) => {
                        return copy r;
                    };
                    Second(w) => {
                        w2 = copy w;
                        return unpack w2:.Wrapper[IntU8.U8];
                    };
                };
             };
             Ctr2(tup) => {
                return copy field[0] tup:Tuple.Tuple2[IntU8.U8,.Wrapper[IntU8.U8]];
             };
             Ctr3(r) => {
                return copy r;
             };
             Ctr4(w) => {
                w2 = copy w;
                return unpack w2:.Wrapper[IntU8.U8];
             };
             Ctr5(w) => {
                return copy field[0] w:.Wrapper[IntU8.U8];
             };
        };
   };

   public transactional fun CreateStuff():() {
        a = lit 1:IntU8.U8;
        aa = copy a;
        w = pack .Wrapper[IntU8.U8]#Ctr(aa);
        c11 = copy a;
        a11 = pack Alt.Alt2[IntU8.U8,.Wrapper[IntU8.U8]]#First(c11);
        t11 = pack .Test[IntU8.U8,.Wrapper[IntU8.U8]]#Ctr1(a11);
        c12 = copy w;
        a12 = pack Alt.Alt2[IntU8.U8,.Wrapper[IntU8.U8]]#Second(c12);
        t12 = pack .Test[IntU8.U8,.Wrapper[IntU8.U8]]#Ctr1(a12);
        c21 = copy a;
        c22 = copy w;
        a2 = pack Tuple.Tuple2[IntU8.U8,.Wrapper[IntU8.U8]]#Tuple(c21,c22);
        t2 = pack .Test[IntU8.U8,.Wrapper[IntU8.U8]]#Ctr2(a2);
        a3 = copy a;
        t3 = pack .Test[IntU8.U8,.Wrapper[IntU8.U8]]#Ctr3(a3);
        a4 = copy w;
        t4 = pack .Test[IntU8.U8,.Wrapper[IntU8.U8]]#Ctr4(a4);
        a5 = copy w;
        t5 = pack .Test[IntU8.U8,.Wrapper[IntU8.U8]]#Ctr5(a5);
        br11 = call .CopyOut(t11);
        br12 = call .CopyOut(t12);
        br2 = call .CopyOut(t2);
        br3 = call .CopyOut(t3);
        br4 = call .CopyOut(t4);
        br5 = call .CopyOut(t5);
        () = call Helpers.AssertEqU8(a,br11);
        () = call Helpers.AssertEqU8(a,br12);
        () = call Helpers.AssertEqU8(a,br2);
        () = call Helpers.AssertEqU8(a,br3);
        () = call Helpers.AssertEqU8(a,br4);
        () = call Helpers.AssertEqU8(a,br5);
        discard (br11,br12,br2,br3,br4,br5);
        r11 = call .Extract(t11);
        r12 = call .Extract(t12);
        r2 = call .Extract(t2);
        r3 = call .Extract(t3);
        r4 = call .Extract(t4);
        r5 = call .Extract(t5);
        () = call Helpers.AssertEqU8(a,r11);
        () = call Helpers.AssertEqU8(a,r12);
        () = call Helpers.AssertEqU8(a,r2);
        () = call Helpers.AssertEqU8(a,r3);
        () = call Helpers.AssertEqU8(a,r4);
        () = call Helpers.AssertEqU8(a,r5);
        return;
   };

    public fun Pack[<Unbound> A](consume a:A):(w:.Wrapper[A]){
        return pack .Wrapper[A]#Ctr(a);
    };

    public fun Unpack[<Unbound> A](consume w:.Wrapper[A]):(a:A){
        return unpack w:.Wrapper[A];
    };
    public fun Pack2[<Unbound> A,<Unbound> B](consume a:A,consume b:B):(w:.TwoOfTwo[A,B]){
        return pack .TwoOfTwo[A,B]#Ctr1(a,b);
    };

    public transactional fun Unpack2[<Unbound> A,<Unbound> B](consume w:.TwoOfTwo[A,B]):(a:A,b:B){
        return switch w:.TwoOfTwo[A,B] {
              Ctr1(a,b) => {
                  return (a,b);
              };
              Ctr2(b,a) => {
                  return (a,b);
              };
          };
    };
}